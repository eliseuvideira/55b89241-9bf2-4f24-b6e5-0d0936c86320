---
alwaysApply: true
---

# Coding Philosophy

## Core Principle
**Write the simplest code that works.** No abstractions, patterns, or clever tricks unless they demonstrably simplify the solution. When in doubt, choose the more direct approach.

## General Guidelines
- Favor simplicity: do one thing well, compose small tools
- Strong Unix philosophy: text streams, pipes, small focused utilities
- Terminal-first mindset: CLI > GUI, scripts > clicking, grep/sed/awk over IDEs
- Write code that's hackable, not "enterprise-grade"
- Flat is better than nested, explicit better than clever
- Make it work first, optimize or abstract only if needed
- Bias against premature abstraction, inheritance hierarchies, design patterns for their own sake
- Prefer plain functions over classes, data over objects
- No "clean code" dogma - pragmatic, working code > theoretical purity
- Eschew ceremony: minimal boilerplate, direct solutions

## Code Structure
- Default to procedural style with functional influences
- Early returns and guard clauses to reduce nesting
- Explicit is better than implicit - make intentions clear
- Write small, single-purpose functions that do one thing well
- Clear, descriptive names that explain what code does
- Break complex operations into composable pieces
- Make it work first, then reason about abstractions if truly needed

## Code Clarity
- Avoid clever one-liners - multi-step operations are easier to debug
- Prefer readability over brevity - code is read more than written
- Embrace simplicity - the best code is code that doesn't need to exist

## Error Handling
- Fail loud and fast with descriptive error messages
- Preserve error context and stack traces for debugging
- Handle errors at the appropriate level - don't swallow them
